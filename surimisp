#!/usr/bin/python
"""
Copyright(C) 2014, Stamus Networks
Written by Eric Leblond <eleblond@stamus-networks.com>

"""

import argparse
import logging
import time
import simplejson as json
from pygtail import Pygtail
from subprocess import call

from threading import *
from Queue import *

q = Queue()

have_daemon = True
try:
    import daemon
except:
    logging.warning("No daemon support available, install python-daemon if feature is needed")
    have_daemon = False

parser = argparse.ArgumentParser(description='Suricata MISP IOC script')
parser.add_argument('-f', '--file', default='/var/log/suricata/eve.json', help='JSON file to monitor')
parser.add_argument('-v', '--verbose', default=False, action="count", help="Show verbose output, use multiple times increase verbosity")
parser.add_argument('-l', '--log', default=None, help='File to log output to (default to stdout)')
parser.add_argument('-o', '--offset', default=None, help='File to write offset to')
parser.add_argument('-b', '--batch', default=False, action="store_true", help="Read file and exit at end")
parser.add_argument('-w', '--workers', default=2, help='Number of alert workers to start')
if have_daemon:
    parser.add_argument('-D', '--daemon', default=False, action="store_true", help="Run as unix daemon")

args = parser.parse_args()

if args.verbose >= 3:
    loglevel=logging.DEBUG
elif args.verbose >= 2:
    loglevel=logging.INFO
elif args.verbose >= 1:
    loglevel=logging.WARNING
else:
    loglevel=logging.ERROR

def setup_logging(args):
    if args.log:
        logging.basicConfig(filename=args.log,
                            format='%(asctime)s %(name)-12s %(levelname)-8s %(message)s',
                            level=loglevel)
    else:
        logging.basicConfig(level=loglevel)

def load_data(dfile):
    iocfile = open(dfile, 'r')
    entries = []
    for line in iocfile:
        entries.append(line.rstrip('\n'))
    return set(entries)

hostname_list = None
domain_list = None
url_list = None
count = { 'hostname': 0, 'url': 0, 'domain': 0 }
 
def check_http(event):
    global count
    try:
        if event['http']['hostname'] in hostname_list:
           event['ioc'] = 'hostname'
           q.put(event)
           count['hostname'] = count['hostname'] + 1
        if event['http']['url'] in url_list:
           event['ioc'] = 'url'
           q.put(event)
           count['url'] = count['url'] + 1
    except:
        pass

def check_dns(event):
    try:
        if event['dns']['rrname'] in domain_list:
           event['ioc'] = 'domain'
           q.put(event)
           count['domain'] = count['domain'] + 1
    except:
        pass

def AlertSender():
    while True:
        event = q.get()
        if event['ioc'] == 'hostname':
            print event['http']['hostname']
        q.task_done()

def main_task(args):
    global hostname_list
    setup_logging(args)

    q = Queue()
    for i in range(args.workers):
        t = Thread(target=AlertSender)
        t.daemon = True
        t.start()

    if args.batch:
        start_time = time.clock()
    hostname_list = load_data('data/misp.hostname.txt')
    domain_list = load_data('data/misp.domain.txt')
    url_list = load_data('data/misp.url.txt')
    if args.batch:
        end_time = time.clock()
        logging.info("Building sets took %fs" % (end_time - start_time))

    # init MISP data
    #fetch_misp_data() 
    if args.batch:
        source = open(args.file, 'r')
    else:
        source = Pygtail(args.file, offset_file=args.offset)

    if args.batch:
        start_time = time.clock()
    for line in source:
        try:
            event = json.loads(line)
        except json.decoder.JSONDecodeError:
            time.sleep(0.3)
            continue
        if event.has_key('event_type'):
            if event['event_type'] == 'http':
                check_http(event)
            elif event['event_type'] == 'dns':
                check_dns(event)

    if args.batch:
        end_time = time.clock()
        logging.info("Matching took %fs" % (end_time - start_time))
        logging.info("Count: " + repr(count))

if have_daemon and args.daemon:
    with daemon.DaemonContext():
        main_task(args)
else:
    main_task(args)
